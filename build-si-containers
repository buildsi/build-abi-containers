#!/usr/bin/env python3

# This script does the following.
# 1. Take one or more test names (e.g., mpich) from the command line
# 2. Take one or more testers found in testers/ (default to libabigail)
# 3. For each test, for each tester, build a container that spack installs the
#    software on top of the testers container.
# 4. Install the script/library here to run the tests
# 5. Output should be saved to a namespaced folder, <tester>/<package>/etc
# 6. We will need a way to compare output.


import argparse
import shutil
import logging
import tempfile
import jsonschema
import os
import re
import json
import calendar
import subprocess
import time
import shutil
import yaml
import sys

from jinja2 import Environment, FileSystemLoader, select_autoescape

logging.basicConfig(level=logging.INFO)

# We want the root
here = os.path.abspath(os.path.dirname(__file__))
templates = os.path.join(here, "templates")

env = Environment(
    autoescape=select_autoescape(["html"]), loader=FileSystemLoader(templates)
)

config_schema = {
    "$schema": "http://json-schema.org/schema#",
    "title": "build-abi-containers package schema",
    "type": "object",
    "additionalProperties": False,
    "properties": {
        "package": {
            "type": "object",
            "additionalProperties": False,
            "properties": {
                "name": {"type": "string"},
                "versions": {"type": "array", "items": {"type": "string"}},
                "headers": {"type": "array", "items": {"type": "string"}},
                "libs": {"type": "array", "items": {"type": "string"}},
            },
        }
    },
}

tester_schema = {
    "$schema": "http://json-schema.org/schema#",
    "title": "build-abi-containers tester schema",
    "type": "object",
    "additionalProperties": False,
    "properties": {
        "tester": {
            "type": "object",
            "additionalProperties": False,
            "properties": {
                "name": {"type": "string"},
                "runscript": {"type": "string"},
                "entrypoint": {"type": "string"},
                "version": {"type": "string"},
            },
        }
    },
}


class Tester:
    def __init__(self, tester_config):
        """A tester is software like libabigail to analyze ABI"""
        self.config = read_yaml(tester_config)
        jsonschema.validate(self.config, schema=tester_schema)

    @property
    def version(self):
        return self.config["tester"]["version"]

    @property
    def name(self):
        return self.config["tester"]["name"]

    @property
    def entrypoint(self):
        return self.config["tester"]["entrypoint"]

    @property
    def runscript(self):
        return self.config["tester"]["runscript"]


class TestPackage:
    def __init__(self, package_config):
        """A package to be tested with a tester."""
        self.config = read_yaml(package_config)
        jsonschema.validate(self.config, schema=config_schema)

    @property
    def versions(self):
        return self.config["package"]["versions"]

    @property
    def libs(self):
        return self.config["package"]["libs"]

    @property
    def include(self):
        return self.config["package"]["headers"]

    @property
    def name(self):
        return self.config["package"]["name"]


class TestSetup:
    def __init__(self, root):
        """A build-si-containers test setup will look for tests/testers"""
        self.root = root
        self.check_root()
        self.load_testers()
        self.docker_images()

    @property
    def test_dir(self):
        return os.path.join(self.root, "tests")

    @property
    def templates_dir(self):
        return os.path.join(self.root, "templates")

    @property
    def testers_dir(self):
        return os.path.join(self.root, "testers")

    def load_testers(self):
        """load tester names based on the Dockerfile extensions"""
        self.testers = set()
        for tester in os.listdir(self.testers_dir):
            self.testers.add(re.sub("[.](yml|yaml)", "", tester))

    def check_root(self):
        """Ensure that the root is structured correctly."""
        for path in self.root, self.test_dir, self.testers_dir, self.templates_dir:
            if not os.path.exists(path):
                sys.exit("% does not exist in the root!" % path)

    def test(self, container, outdir):
        """
        Given a container, run it and bind to an output directory to test
        """
        res = run_command(
            ["docker", "run", "-t", "-v", "%s:/results" % outdir, container],
            to_stdout=True,
        )

    def get_containers(self, package, testers):
        """
        Given a tester and package, generate the list of expected containers.
        """
        containers = []

        # For each testing container, and each version, build
        for tester in self.testers:
            tester = Tester(self.get_tester_config(tester))
            package = TestPackage(self.get_package_config(package))
            containers.append(
                "quay.io/buildsi/%s-test-%s:latest" % (tester.name, package.name)
            )
        return containers

    def docker_images(self):
        """
        Load docker images into the client to determine which already exist.
        """
        images = run_command(["docker", "images"])
        self.containers = []
        for image in images.split("\n"):
            if not image:
                continue
            image, rest = image.split(" ", 1)
            tag = rest.strip().split(" ")[0]
            self.containers.append("%s:%s" % (image, tag))

        self.containers = set(self.containers)

    def build(self, package, testers, use_cache=False, fail_fast=True, skips=None):
        """
        Create a Dockerfile and build
        """
        # Containers to skip building
        skips = skips or []

        # Create the package to test
        package_file = self.get_package_config(package)
        package = TestPackage(package_file)

        # Return a list of containers build to test later
        containers = []

        # For each testing container, and each version, build
        for tester in self.testers:

            # Get the tester build template
            template = self.get_tester_template(tester, use_cache)
            tester = Tester(self.get_tester_config(tester))

            # Right now one container has all versions
            # Does the tester have extra scripts?
            bins = []
            tester_bin = os.path.join(self.testers_dir, tester.name, "bin")
            if os.path.exists(tester_bin):
                for filename in os.listdir(tester_bin):
                    bins.append(filename)

            # Render the template and runtests.py file
            runscript = self.get_tester_runscript(tester).render(
                package=package, tester=tester
            )
            out = template.render(package=package, tester=tester, bins=bins)
            container_name = "quay.io/buildsi/%s-test-%s:latest" % (
                tester.name,
                package.name,
            )

            # Skip building the container if requested to skip
            if container_name in skips:
                containers.append(container_name)
                continue

            with tempfile.TemporaryDirectory() as tmp:
                write_file(out, os.path.join(tmp, "Dockerfile"))
                write_file(runscript, os.path.join(tmp, tester.runscript))
                shutil.copyfile(
                    package_file, os.path.join(tmp, os.path.basename(package_file))
                )

                # If we have extra files to add, copy them
                for binfile in bins:
                    shutil.copyfile(
                        os.path.join(tester_bin, binfile),
                        os.path.join(tmp, binfile),
                    )

                cmd = ["docker", "build", "-t", container_name, tmp]
                res = subprocess.call(cmd)
                if res == 0:
                    containers.append(container_name)
                elif res != 0 and fail_fast:
                    sys.exit("Error building %s" % container_name)
                else:
                    print("Issue building %s, but fail fast not set.")
                    continue
        return containers

    def get_tester_config(self, tester):
        """
        Given a package and tester, return the tester config.
        """
        config_file = os.path.join(self.testers_dir, tester, "tester.yaml")
        if not os.path.exists(config_file):
            sys.exit("%s does not exist!" % config_file)
        return config_file

    def get_package_config(self, package):
        """
        Given a package and tester, return the tester config.
        """
        # If we are given a package file directly, honor it
        if os.path.exists(package):
            return package

        # Look for exact file in the tests directory
        package_file = os.path.join(self.test_dir, package)
        if os.path.exists(package_file):
            return package_file

        # Last resort - the name of the yaml file without extension
        package_file = os.path.join(self.test_dir, "%s.yaml" % package)
        if not os.path.exists(package_file):
            sys.exit("%s does not exist!" % package_file)
        return package_file

    def get_tester_runscript(self, tester):
        """
        Get the runscript for the tester
        """
        template = os.path.join(self.templates_dir, tester.name, tester.runscript)
        if not os.path.exists(template):
            sys.exit("Tester runscript %s does not exist!" % template)
        template = template.replace(self.templates_dir, "").strip("/")
        return env.get_template(template)

    def get_tester_template(self, tester, use_cache=False):
        """
        Given a package and tester, return the container template.
        """
        dockerfile = os.path.join(self.templates_dir, tester, "Dockerfile")
        if not os.path.exists(dockerfile) and not use_cache:
            dockerfile = os.path.join(self.templates_dir, "Dockerfile.default")
        elif not os.path.exists(dockerfile) and use_cache:
            dockerfile = os.path.join(self.templates_dir, "Dockerfile.buildcache")
        dockerfile = dockerfile.replace(self.templates_dir, "").strip("/")
        return env.get_template(dockerfile)


def read_yaml(filename):
    with open(filename, "r") as fd:
        content = yaml.load(fd, Loader=yaml.FullLoader)
    return content


def write_file(content, filename):
    with open(filename, "w") as fd:
        fd.write(content)


def run_command(cmd, to_stdout=False):
    stdout = subprocess.PIPE
    if to_stdout:
        stdout = None
    p = subprocess.Popen(cmd, stdout=stdout, stderr=subprocess.STDOUT)
    out = p.communicate()[0]
    if out:
        out = out.decode("utf-8")
    if p.returncode != 0:
        print(out)
        sys.exit("Error running %s." % " ".join(cmd))
    return out


def get_parser():
    parser = argparse.ArgumentParser(description="Build SI Container Tester")

    description = "actions for testing containers for the BUILD SI project"
    subparsers = parser.add_subparsers(
        help="run-tests actions",
        title="actions",
        description=description,
        dest="command",
    )

    # Run a complete test, which includes building the test container
    test = subparsers.add_parser("test", help="run tests.")
    test.add_argument(
        "--outdir",
        "-o",
        dest="outdir",
        help="Write test results to this directory (defaults to results in $PWD)",
        default=os.path.join(os.getcwd(), "results"),
    )
    test.add_argument(
        "--rebuild",
        dest="rebuild",
        help="Force rebuild of the container if it does not exist.",
        default=False,
        action="store_true",
    )

    # Build a testing container
    build = subparsers.add_parser("build", help="build a testing container.")

    for command in [test, build]:
        command.add_argument("packages", help="packages to test", nargs="+")
        command.add_argument(
            "--root",
            "-r",
            dest="root",
            help="The root with the tests and testers directories.",
            default=os.getcwd(),
        )
        command.add_argument(
            "--use-cache",
            dest="use_cache",
            help="Install from build cache instead of autamus.",
            default=False,
            action="store_true",
        )
        command.add_argument(
            "--fail-fast",
            dest="fail_fast",
            help="If a container build fails, exit.",
            default=True,
            action="store_false",
        )
        command.add_argument(
            "--tester",
            "-t",
            dest="tester",
            help="The tester to run tests for.",
            choices=["libabigail", "all"],
            default="all",
        )
    return parser


def main():
    """
    Entrypoint for running tests.
    """
    parser = get_parser()

    def help(return_code=0):
        parser.print_help()
        sys.exit(return_code)

    # If an error occurs while parsing the arguments, the interpreter will exit with value 2
    args, extra = parser.parse_known_args()
    if not args.command:
        help()

    setup = TestSetup(args.root)

    if args.command == "build":
        for package in args.packages:
            setup.build(package, args.tester, args.use_cache, args.fail_fast)

    elif args.command == "test":
        for package in args.packages:

            # By default, don't skip any builds, unless a rebuild is not wanted
            skips = []
            if not args.rebuild:

                # Skip containers that already exist
                for container in setup.get_containers(package, args.tester):
                    if container in setup.containers:
                        skips.append(container)
            containers = setup.build(
                package, args.tester, args.use_cache, args.fail_fast, skips=skips
            )
            for container in containers:
                setup.test(container, args.outdir)
    else:
        help()


if __name__ == "__main__":
    main()
